/**********************************************
 * MalwareHunter
 *
 * Jacob Gajek <jgajek@gmail.com>
 *
 * v0.1 - January 31, 2015 - Initial release
 **********************************************/

#include "stdafx.h"

#include <mscat.h>
#include <SoftPub.h>
#include <strsafe.h>

#pragma comment(lib, "wintrust")

typedef struct _MODULE_ENTRY {
	DWORD	pid;
	DWORD	ppid;
	LPTSTR	processName;
	LPTSTR	moduleName;
	LPTSTR	execPath;
	TCHAR	fileHash[128];
	TCHAR	verifyStatus[512];
	BOOL	isX86_64;
	WORD	nCatalog;
	BOOL	isSigned;
	BOOL	isValid;
} MODULE_ENTRY, *PMODULE_ENTRY;


BOOL VerifySignature(LPCWSTR path, PMODULE_ENTRY pme);

VOID PrintModule(PMODULE_ENTRY pme)
{
	_tprintf(TEXT("%04d|%04d|%s|%s|%s|%s|%s|%d|%s|%s\n"),
		pme->pid,
		pme->ppid,
		pme->processName,
		pme->moduleName,
		pme->execPath,
		pme->fileHash,
		pme->verifyStatus,
		pme->nCatalog,
		pme->isSigned ? TEXT("true") : TEXT("false"),
		pme->isValid ? TEXT("true") : TEXT("false"));
}

VOID PrintHash(PMODULE_ENTRY pme, PBYTE pbHash, DWORD cbHash)
{
	static TCHAR hex_char[] = {
		TEXT('0'), TEXT('1'), TEXT('2'), TEXT('3'), TEXT('4'), TEXT('5'), TEXT('6'), TEXT('7'),
		TEXT('8'), TEXT('9'), TEXT('a'), TEXT('b'), TEXT('c'), TEXT('d'), TEXT('e'), TEXT('f')
	};

	UINT i, j;

	for (i = 0, j = 0; i < cbHash && j < ARRAYSIZE(pme->fileHash) - 1; i++, j += 2)
	{
		pme->fileHash[j] = hex_char[(pbHash[i] & 0xF0) >> 4];
		pme->fileHash[j + 1] = hex_char[pbHash[i] & 0x0F];
	}

	pme->fileHash[j] = TEXT('\0');
}

VOID PrintStatus(PMODULE_ENTRY pme, LPTSTR msg)
{
	TCHAR sysmsg[256];

	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		sysmsg,
		ARRAYSIZE(sysmsg),
		NULL);

	StringCchPrintf(pme->verifyStatus, ARRAYSIZE(pme->verifyStatus), TEXT("%s: %s"), msg, sysmsg);
}

BOOL VerifySignature(LPCWSTR path, PMODULE_ENTRY pme)
{
	HCATADMIN hCatAdmin;
	HCATINFO hCatInfo;
	CATALOG_INFO CatInfo;
	HANDLE hFile;
	DWORD cbHash;
	PBYTE pbHash;
	GUID gAction;
	WINTRUST_DATA WinTrustData;
	WINTRUST_CATALOG_INFO WinTrustCatalog;
	WINTRUST_FILE_INFO WinTrustFile;
	
	// Initialize result fields with default values.
	pme->nCatalog = 0;
	pme->isSigned = FALSE;
	pme->isValid = FALSE;

	// Acquire administrator context for signature validation using catalog database.
	if (!CryptCATAdminAcquireContext(&hCatAdmin, NULL, 0))
	{
		PrintStatus(pme, TEXT("CryptCATAdminAcquireContext error"));
		return FALSE;
	}

	// Open the file whose signature is to be verified for reading.
	hFile = CreateFile(path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		PrintStatus(pme, TEXT("CreateFile error"));
		CryptCATAdminReleaseContext(hCatAdmin, NULL);
		return FALSE;
	}

	// Calculate size of buffer needed to store the hash value.
	if (!CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, NULL, 0))
	{
		PrintStatus(pme, TEXT("CryptCATAdminCalcHashFromFileHandle error"));
		CloseHandle(hFile);
		CryptCATAdminReleaseContext(hCatAdmin, NULL);
		return FALSE;
	}

	// Allocate memory for hash.
	pbHash = (PBYTE)CoTaskMemAlloc(cbHash);
	if (pbHash == NULL)
	{
		PrintStatus(pme, TEXT("CoTaskMemAlloc error"));
		CloseHandle(hFile);
		CryptCATAdminReleaseContext(hCatAdmin, NULL);
		return FALSE;
	}

	// Calculate hash of file.
	if (!CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, pbHash, 0))
	{
		PrintStatus(pme, TEXT("CryptCATAdminCalcHashFromFileHandle error"));
		CloseHandle(hFile);
		CoTaskMemFree(pbHash);
		CryptCATAdminReleaseContext(hCatAdmin, NULL);
		return FALSE;
	}

	// Convert file hash to hex string.
	PrintHash(pme, pbHash, cbHash);

	/*----------------------------------------------------*/
	/* Try to locate the file hash in a catalog database. */
	/*----------------------------------------------------*/
	
	gAction = WINTRUST_ACTION_GENERIC_VERIFY_V2;

	WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
	WinTrustData.pPolicyCallbackData = NULL;
	WinTrustData.pSIPClientData = NULL;
	WinTrustData.dwUIChoice = WTD_UI_NONE;
	WinTrustData.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
	WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
	WinTrustData.hWVTStateData = NULL;
	WinTrustData.pwszURLReference = NULL;
	WinTrustData.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN;
	WinTrustData.pCatalog = &WinTrustCatalog;
	WinTrustData.hWVTStateData = NULL;
	WinTrustData.dwUIContext = WTD_UICONTEXT_EXECUTE;
	WinTrustData.pSignatureSettings = NULL;

	WinTrustCatalog.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
	WinTrustCatalog.dwCatalogVersion = 0;
	WinTrustCatalog.pcwszCatalogFilePath = CatInfo.wszCatalogFile;
	WinTrustCatalog.pcwszMemberTag = NULL;
	WinTrustCatalog.pcwszMemberFilePath = path;
	WinTrustCatalog.hMemberFile = hFile;
	WinTrustCatalog.pbCalculatedFileHash = pbHash;
	WinTrustCatalog.cbCalculatedFileHash = cbHash;
	WinTrustCatalog.pcCatalogContext = NULL;
	WinTrustCatalog.hCatAdmin = hCatAdmin;

	CatInfo.cbStruct = sizeof(CATALOG_INFO);

	// Get list of catalogs that contain the calculated hash, and verify the digital signature against each one.
	hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash, cbHash, 0, NULL);
	while (hCatInfo != NULL)
	{
		if (CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0))
		{
			pme->nCatalog++;

			if (!pme->isValid)
			{
				WinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;

				if (WinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &gAction, &WinTrustData) == 0)
				{
					StringCchPrintf(pme->verifyStatus, ARRAYSIZE(pme->verifyStatus), TEXT("Catalog verification success"));
					pme->isValid = TRUE;
				}
				else
				{
					PrintStatus(pme, TEXT("Catalog verification error"));
				}

				WinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;
				WinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &gAction, &WinTrustData);
			}
		}
		hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash, cbHash, 0, &hCatInfo);
	}

	CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
	CryptCATAdminReleaseContext(hCatAdmin, 0);

	CoTaskMemFree(pbHash);

	/*-----------------------------------------------*/
	/* Try to verify the embedded signature in file. */
	/*-----------------------------------------------*/

	WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
	WinTrustData.pFile = &WinTrustFile;

	WinTrustFile.cbStruct = sizeof(WINTRUST_FILE_INFO);
	WinTrustFile.pcwszFilePath = path;
	WinTrustFile.hFile = hFile;
	WinTrustFile.pgKnownSubject = NULL;

	WinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;
	if (WinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &gAction, &WinTrustData) == 0)
	{
		StringCchPrintf(pme->verifyStatus, ARRAYSIZE(pme->verifyStatus), TEXT("Embedded signature verification success"));
		pme->isSigned = TRUE;
		pme->isValid = TRUE;
	}
	else
	{
		if (!pme->isValid)
		{
			PrintStatus(pme, TEXT("Embedded signature verification error"));
		}
	}

	WinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;
	WinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &gAction, &WinTrustData);

	CloseHandle(hFile);
	return TRUE;
}

BOOL EnumModules(DWORD pid, DWORD ppid, LPTSTR exe, BOOL showAll)
{
	HANDLE hModuleSnapshot;
	MODULEENTRY32 me32;
	MODULE_ENTRY me;

	// Take a snapshot of all modules in the process.
	hModuleSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
	if (hModuleSnapshot == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	me32.dwSize = sizeof(MODULEENTRY32);

	// Get info for first process in snapshot.
	if (!Module32First(hModuleSnapshot, &me32))
	{
		CloseHandle(hModuleSnapshot);
		return FALSE;
	}

	me.pid = pid;
	me.ppid = ppid;
	me.processName = exe;
	me.moduleName = me32.szModule;
	me.execPath = me32.szExePath;

	VerifySignature(me32.szExePath, &me);

	if (showAll || !me.isValid)
	{
		PrintModule(&me);
	}

	while (Module32Next(hModuleSnapshot, &me32))
	{
		VerifySignature(me32.szExePath, &me);

		if (showAll || !me.isValid)
		{
			PrintModule(&me);
		}
	}

	// Clean up.
	CloseHandle(hModuleSnapshot);
	return TRUE;
}

BOOL EnumProcesses(BOOL showAll)
{
	HANDLE hProcessSnapshot;
	PROCESSENTRY32 pe32;

	// Take a snapshot of all processes in the system.
	hProcessSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hProcessSnapshot == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	pe32.dwSize = sizeof(PROCESSENTRY32);

	// Get info for first process in snapshot.
	if (!Process32First(hProcessSnapshot, &pe32))
	{
		CloseHandle(hProcessSnapshot);
		return FALSE;
	}

	// Enumerate all modules loaded into process address space.
	EnumModules(pe32.th32ProcessID, pe32.th32ParentProcessID, pe32.szExeFile, showAll);

	while (Process32Next(hProcessSnapshot, &pe32))
	{
		EnumModules(pe32.th32ProcessID, pe32.th32ParentProcessID, pe32.szExeFile, showAll);
	}

	// Clean up.
	CloseHandle(hProcessSnapshot);
	return TRUE;
}

int _tmain(int argc, _TCHAR* argv[])
{
	EnumProcesses(FALSE);
	return 0;
}
