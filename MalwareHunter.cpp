// MalwareHunter - A malware detection tool for Windows operating systems.
//
// Author: Jacob Gajek <jgajek@gmail.com>
//
// This code is in the public domain.

#include "stdafx.h"

#include <mscat.h>
#include <SoftPub.h>
#include <strsafe.h>
#include <wincrypt.h>

#pragma comment(lib, "wintrust")
#pragma comment(lib, "crypt32")

#define LOG(msg)

/*-----------------------------*
 * Process entry structure     *
 *-----------------------------*/

typedef struct _PROCESS_ENTRY {
	LPTSTR	exeName;
	LPTSTR	exePath;
	TCHAR	exeHash[128];
	TCHAR	signer[512];
	TCHAR	issuer[512];
	BOOL	isValid;
} PROCESS_ENTRY, *PPROCESS_ENTRY;

VOID LogMessage(LPCTSTR msg);
VOID PrintProcessEntry(PPROCESS_ENTRY ppe);
VOID ConvertHash(TCHAR szBuffer[], DWORD ccBuffer, PBYTE pbHash, DWORD cbHash);
BOOL VerifySignature(PPROCESS_ENTRY ppe);
BOOL GetSignatureInfo(LPCWSTR path, PPROCESS_ENTRY ppe);

// Log message to console
VOID LogMessage(LPCTSTR msg)
{
	TCHAR sysmsg[512];

	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
		NULL,
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		sysmsg,
		ARRAYSIZE(sysmsg),
		NULL);

	_tprintf(TEXT("%s: %s\n"), msg, sysmsg);
}

// Print out pipe-delimited process entry fields
VOID PrintProcessEntry(PPROCESS_ENTRY ppe)
{
	_tprintf(TEXT("%s|%s|%s|%s|%s|%s\n"),
		ppe->exeName,
		ppe->exePath,
		ppe->exeHash,
		ppe->signer,
		ppe->issuer,
		ppe->isValid ? TEXT("Valid") : TEXT("Invalid"));
}

// Convert hash bytes to readable hex string
VOID ConvertHash(TCHAR szBuffer[], DWORD ccBuffer, PBYTE pbHash, DWORD cbHash)
{
	static const TCHAR hex_char[] = {
		TEXT('0'), TEXT('1'), TEXT('2'), TEXT('3'), TEXT('4'), TEXT('5'), TEXT('6'), TEXT('7'),
		TEXT('8'), TEXT('9'), TEXT('a'), TEXT('b'), TEXT('c'), TEXT('d'), TEXT('e'), TEXT('f')
	};

	UINT i, j;

	for (i = 0, j = 0; i < cbHash && j < ccBuffer - 1; i++, j += 2)
	{
		szBuffer[j] = hex_char[(pbHash[i] & 0xF0) >> 4];
		szBuffer[j + 1] = hex_char[pbHash[i] & 0x0F];
	}

	szBuffer[j] = TEXT('\0');
}

// Get subject name of signer certificate
BOOL GetSignatureInfo(LPCWSTR filePath, PPROCESS_ENTRY ppe)
{
	HCERTSTORE hStore;
	HCRYPTMSG hMsg;
	PCMSG_SIGNER_INFO pSigner;
	PCCERT_CONTEXT pCert;
	CERT_INFO certInfo;
	DWORD dwEncoding;
	DWORD dwContent;
	DWORD dwFormat;
	DWORD cbData;

	// Extract digital signature info from file
	if (!CryptQueryObject(CERT_QUERY_OBJECT_FILE, filePath, CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED, CERT_QUERY_FORMAT_FLAG_BINARY,
		0, &dwEncoding, &dwContent, &dwFormat, &hStore, &hMsg, NULL))
	{
		StringCchPrintf(ppe->signer, ARRAYSIZE(ppe->signer), TEXT("(signature not found)"));
		StringCchPrintf(ppe->issuer, ARRAYSIZE(ppe->issuer), TEXT("(signature not found)"));
		return FALSE;
	}

	StringCchPrintf(ppe->signer, ARRAYSIZE(ppe->signer), TEXT("(error processing signature"));
	StringCchPrintf(ppe->issuer, ARRAYSIZE(ppe->issuer), TEXT("(error processing signature"));

	// Get size of signer info
	if (!CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, NULL, &cbData))
	{
		LOG(TEXT("CryptMsgGetParam error"));
		CertCloseStore(hStore, 0);
		CryptMsgClose(hMsg);
		return FALSE;
	}

	// Allocate memory for signer info
	pSigner = (PCMSG_SIGNER_INFO)malloc(cbData);
	if (pSigner == NULL)
	{
		LOG(TEXT("Memory allocation error"));
		CertCloseStore(hStore, 0);
		CryptMsgClose(hMsg);
		return FALSE;
	}

	// Extract signer info
	if (!CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, pSigner, &cbData))
	{
		LOG(TEXT("CryptMsgGetParam error"));
		CertCloseStore(hStore, 0);
		CryptMsgClose(hMsg);
		free(pSigner);
		return FALSE;
	}

	certInfo.Issuer = pSigner->Issuer;
	certInfo.SerialNumber = pSigner->SerialNumber;

	// Get signer certificate context
	pCert = CertFindCertificateInStore(hStore, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0, CERT_FIND_SUBJECT_CERT, &certInfo, NULL);
	if (pCert == NULL)
	{
		LOG(TEXT("CertFindCertificateInStore error"));
		CertCloseStore(hStore, 0);
		CryptMsgClose(hMsg);
		free(pSigner);
		return FALSE;
	}

	// Extract signer and issuer names
	CertGetNameString(pCert, CERT_NAME_FRIENDLY_DISPLAY_TYPE, 0, NULL, ppe->signer, ARRAYSIZE(ppe->signer));
	CertGetNameString(pCert, CERT_NAME_FRIENDLY_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, NULL, ppe->issuer, ARRAYSIZE(ppe->issuer));

	// Clean up
	CertFreeCertificateContext(pCert);
	CertCloseStore(hStore, 0);
	CryptMsgClose(hMsg);
	free(pSigner);
	return TRUE;
}

// Verify digital signature of process entry
BOOL VerifySignature(PPROCESS_ENTRY ppe)
{
	HCATADMIN hCatAdmin;
	HCATINFO hCatInfo;
	CATALOG_INFO CatInfo = {};
	HANDLE hFile;
	DWORD cbHash;
	PBYTE pbHash;
	GUID gAction;
	WINTRUST_DATA WinTrustData = {};
	WINTRUST_CATALOG_INFO WinTrustCatalog = {};
	WINTRUST_FILE_INFO WinTrustFile = {};

	ppe->isValid = FALSE;

	// Acquire administrator context for signature validation using catalog database.
	if (!CryptCATAdminAcquireContext(&hCatAdmin, NULL, 0))
	{
		LOG(TEXT("CryptCATAdminAcquireContext error"));
		return FALSE;
	}

	// Open executable file for reading.
	hFile = CreateFile(ppe->exePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		LOG(TEXT("CreateFile error"));
		CryptCATAdminReleaseContext(hCatAdmin, NULL);
		return FALSE;
	}

	// Calculate size of buffer needed to store the hash value.
	if (!CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, NULL, 0))
	{
		LOG(TEXT("CryptCATAdminCalcHashFromFileHandle error"));
		CloseHandle(hFile);
		CryptCATAdminReleaseContext(hCatAdmin, NULL);
		return FALSE;
	}

	// Allocate memory for hash.
	pbHash = (PBYTE)malloc(cbHash);
	if (pbHash == NULL)
	{
		LOG(TEXT("Memory allocation error"));
		CloseHandle(hFile);
		CryptCATAdminReleaseContext(hCatAdmin, NULL);
		return FALSE;
	}

	// Calculate hash of file.
	if (!CryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, pbHash, 0))
	{
		LOG(TEXT("CryptCATAdminCalcHashFromFileHandle error"));
		CloseHandle(hFile);
		free(pbHash);
		CryptCATAdminReleaseContext(hCatAdmin, NULL);
		return FALSE;
	}

	// Convert file hash to hex string.
	ConvertHash(ppe->exeHash, ARRAYSIZE(ppe->exeHash), pbHash, cbHash);

	/*----------------------------------------------------*/
	/* Try to locate the file hash in a catalog database. */
	/*----------------------------------------------------*/
	
	gAction = WINTRUST_ACTION_GENERIC_VERIFY_V2;

	WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
	WinTrustData.pPolicyCallbackData = NULL;
	WinTrustData.pSIPClientData = NULL;
	WinTrustData.dwUIChoice = WTD_UI_NONE;
	WinTrustData.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
	WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
	WinTrustData.hWVTStateData = NULL;
	WinTrustData.pwszURLReference = NULL;
	WinTrustData.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN;
	WinTrustData.pCatalog = &WinTrustCatalog;
	WinTrustData.dwUIContext = WTD_UICONTEXT_EXECUTE;

	WinTrustCatalog.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
	WinTrustCatalog.dwCatalogVersion = 0;
	WinTrustCatalog.pcwszCatalogFilePath = CatInfo.wszCatalogFile;
	WinTrustCatalog.pcwszMemberTag = NULL;
	WinTrustCatalog.pcwszMemberFilePath = ppe->exePath;
	WinTrustCatalog.hMemberFile = hFile;
	WinTrustCatalog.pbCalculatedFileHash = pbHash;
	WinTrustCatalog.cbCalculatedFileHash = cbHash;
	WinTrustCatalog.pcCatalogContext = NULL;
	WinTrustCatalog.hCatAdmin = hCatAdmin;

	CatInfo.cbStruct = sizeof(CATALOG_INFO);

	// Traverse list of catalogs that contain the calculated hash, and try to verify the digital signature against each one.
	hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash, cbHash, 0, NULL);
	while (hCatInfo != NULL)
	{
		if (CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0))
		{
			WinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;

			if (WinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &gAction, &WinTrustData) == 0)
			{
				LOG(TEXT("Catalog verification success"));
				GetSignatureInfo(CatInfo.wszCatalogFile, ppe);
				ppe->isValid = TRUE;
			}
			else
			{
				LOG(TEXT("Catalog verification error"));
				GetSignatureInfo(CatInfo.wszCatalogFile, ppe);
				ppe->isValid = FALSE;
			}

			WinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;
			WinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &gAction, &WinTrustData);

			if (ppe->isValid)
			{
				break;
			}
		}
		hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash, cbHash, 0, &hCatInfo);
	}

	CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
	CryptCATAdminReleaseContext(hCatAdmin, 0);

	free(pbHash);

	if (ppe->isValid)
	{
		CloseHandle(hFile);
		return TRUE;
	}

	/*-----------------------------------------------*/
	/* Try to verify the embedded signature in file. */
	/*-----------------------------------------------*/

	WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
	WinTrustData.pFile = &WinTrustFile;

	WinTrustFile.cbStruct = sizeof(WINTRUST_FILE_INFO);
	WinTrustFile.pcwszFilePath = ppe->exePath;
	WinTrustFile.hFile = hFile;

	WinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;
	if (WinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &gAction, &WinTrustData) == 0)
	{
		LOG(TEXT("Embedded signature verification success"));
		GetSignatureInfo(ppe->exePath, ppe);
		ppe->isValid = TRUE;
	}
	else
	{
		LOG(TEXT("Embedded signature verification error"));
		GetSignatureInfo(ppe->exePath, ppe);
		ppe->isValid = FALSE;
	}

	WinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;
	WinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &gAction, &WinTrustData);

	CloseHandle(hFile);
	return TRUE;
}

// List running processes. If showAll is true, then list all processes, otherwise list only processes without a valid signature.
BOOL EnumProcesses(BOOL showAll)
{
	HANDLE hProcessSnapshot;
	HANDLE hModuleSnapshot;
	PROCESSENTRY32 pe32;
	MODULEENTRY32 me32;
	PROCESS_ENTRY pe;

	// Take a snapshot of all processes in the system
	hProcessSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hProcessSnapshot == INVALID_HANDLE_VALUE)
	{
		LOG(TEXT("CreateToolhelp32Snapshot(PROCESS) error"));
		return FALSE;
	}

	pe32.dwSize = sizeof(PROCESSENTRY32);

	// Get info for first process in snapshot
	if (!Process32First(hProcessSnapshot, &pe32))
	{
		LOG(TEXT("Process32First error"));
		CloseHandle(hProcessSnapshot);
		return FALSE;
	}

	hModuleSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pe32.th32ProcessID);
	while (hModuleSnapshot == INVALID_HANDLE_VALUE)
	{
		if (GetLastError() == ERROR_BAD_LENGTH)
		{
			hModuleSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pe32.th32ProcessID);
			continue;
		}
		else
		{
			LOG(TEXT("CreateToolhelp32Snapshot(MODULE) error"));
			break;
		}
	}

	if (hModuleSnapshot != INVALID_HANDLE_VALUE)
	{
		me32.dwSize = sizeof(MODULEENTRY32);

		if (!Module32First(hModuleSnapshot, &me32))
		{
			LOG(TEXT("Module32First error"));
		}
		else
		{
			pe.exeName = pe32.szExeFile;
			pe.exePath = me32.szExePath;
			VerifySignature(&pe);

			if (showAll || !pe.isValid)
			{
				PrintProcessEntry(&pe);
			}
		}

		CloseHandle(hModuleSnapshot);
	}

	// Traverse list of running processes
	while (Process32Next(hProcessSnapshot, &pe32))
	{
		hModuleSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pe32.th32ProcessID);
		while (hModuleSnapshot == INVALID_HANDLE_VALUE)
		{
			if (GetLastError() == ERROR_BAD_LENGTH)
			{
				hModuleSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pe32.th32ProcessID);
				continue;
			}
			else
			{
				LOG(TEXT("CreateToolhelp32Snapshot(MODULE) error"));
				break;
			}
		}

		if (hModuleSnapshot != INVALID_HANDLE_VALUE)
		{
			me32.dwSize = sizeof(MODULEENTRY32);

			if (!Module32First(hModuleSnapshot, &me32))
			{
				LOG(TEXT("Module32First error"));
			}
			else
			{
				pe.exeName = pe32.szExeFile;
				pe.exePath = me32.szExePath;
				VerifySignature(&pe);

				if (showAll || !pe.isValid)
				{
					PrintProcessEntry(&pe);
				}
			}

			CloseHandle(hModuleSnapshot);
		}
	}

	// Clean up
	CloseHandle(hProcessSnapshot);
	return TRUE;
}


int _tmain(int argc, _TCHAR* argv[])
{
	BOOL showAll = FALSE;

	for (WORD i = 1; i < argc; i++)
	{
		if (!lstrcmp(argv[i], TEXT("-a")))
		{
			showAll = TRUE;
		}
	}

	EnumProcesses(showAll);
	return 0;
}
